import xml.etree.ElementTree as ET
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
import warnings
from pathlib import Path
import random
import glob
import tensorflow as tf
from tensorflow.keras.layers import Dense, Flatten, GlobalAveragePooling2D
from tensorflow.keras.preprocessing.image import ImageDataGenerator

image_path = '/kaggle/input/roads-segmentation-dataset/images'
mask_path  = '/kaggle/input/roads-segmentation-dataset/masks'

def display_image(image_folder):
    
    image_files = [f for f in (os.listdir(image_folder)) if f.endswith(('jpg','png','jpeg'))]
    
    #print(image_files)
    
    fig,axes = plt.subplots(3,3,figsize=(10,10))
    
    for i, file_name in enumerate(image_files):  
        
        if i>=9:
            break
        row = i//3
        col = i%3
        
         # Load and display the image in the current subplot
        image_path = os.path.join(image_folder, file_name)
        image = cv2.imread(image_path)
        axes[row, col].imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        axes[row, col].set_title(file_name)
        axes[row, col].axis('off')
        
        
    # Ensure proper layout and show the plots
    plt.tight_layout()
    plt.show()

# Specify the folder path containing the images
image_folder = '/kaggle/input/roads-segmentation-dataset/images'  # Replace with the path to your image folder
display_image(image_folder)

def mask_image(image_folder):
    
    image_files = [f for f in (os.listdir(image_folder)) if f.endswith(('jpg','png','jpeg'))]
    
    #print(image_files)
    
    fig,axes = plt.subplots(3,3,figsize=(10,10))
    
    for i, file_name in enumerate(image_files):  
        
        if i>=9:
            break
        row = i//3
        col = i%3
        
         # Load and display the image in the current subplot
        image_path = os.path.join(image_folder, file_name)
        image = cv2.imread(image_path)
        axes[row, col].imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        axes[row, col].set_title(file_name)
        axes[row, col].axis('off')
        
        
    # Ensure proper layout and show the plots
    plt.tight_layout()
    plt.show()

image_path = "/kaggle/input/roads-segmentation-dataset/images/*.png"
mask_path = "/kaggle/input/roads-segmentation-dataset/masks/*.png"
image_paths = sorted(glob.glob(image_path), key=lambda x: x.split('.')[0])
mask_paths = sorted(glob.glob(mask_path), key=lambda x: x.split('.')[0])

def resize_image(image, size):
    # Resize the image to the specified size
    resized_image = cv2.resize(image, size)
    return resized_image

def resize_mask(mask, size):
    # Convert the mask to grayscale
    mask_gray = cv2.cvtColor(mask, cv2.COLOR_RGB2GRAY)
    resized_mask = cv2.resize(mask_gray, size, interpolation=cv2.INTER_NEAREST)
    resized_mask = np.expand_dims(resized_mask, axis=2)
    return resized_maskdef resize_image(image, size):
    # Resize the image to the specified size
    resized_image = cv2.resize(image, size)
    return resized_image

# Define the desired size
target_size = (512,512)
image_list = []
mask_list = []
for image_path, mask_path in zip(image_paths, mask_paths):
    # Load the image and mask
    image = plt.imread(image_path).astype(np.float32)
    mask = plt.imread(mask_path).astype(np.float32)

    # Resize the image and mask
    resized_image = resize_image(image, target_size)
    resized_mask = resize_mask(mask, target_size)

    image_list.append(resized_image)
    mask_list.append(resized_mask)

# Convert the image and mask lists to arrays
image_array = np.array(image_list)
mask_array = np.array(mask_list)

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(image_array,mask_array, test_size=0.2, random_state=23)

import tensorflow as tf

def create_unet_model(input_shape=(512, 512, 3)):
    # Define the input layer
    x = tf.keras.layers.Input(input_shape)

    # Encoder layers
    enc1 = tf.keras.layers.Conv2D(64, (3, 3), padding='same', activation='relu')(x)
    enc2 = tf.keras.layers.Conv2D(64, (3, 3), padding='same', activation='relu')(enc1)
    enc3 = tf.keras.layers.MaxPooling2D((2, 2))(enc2)
    enc3 = tf.keras.layers.Conv2D(64, (3, 3), padding='same', activation='relu')(enc3)
    enc4 = tf.keras.layers.Conv2D(128, (3, 3), padding='same', activation='relu')(enc3)
    enc5 = tf.keras.layers.Conv2D(128, (3, 3), padding='same', activation='relu')(enc4)
    enc6 = tf.keras.layers.MaxPooling2D((2, 2))(enc5)
    enc6 = tf.keras.layers.Conv2D(64, (3, 3), padding='same', activation='relu')(enc6)
    enc7 = tf.keras.layers.Conv2D(256, (3, 3), padding='same', activation='relu')(enc6)
    enc8 = tf.keras.layers.Conv2D(1, (3, 3), padding='same', activation='relu')(enc7)

    # Skip connections
    skip1 = enc2
    skip2 = enc5

    # Decoder layers
    dec1 = tf.keras.layers.UpSampling2D((2, 2))(enc8)
    dec1 = tf.keras.layers.Concatenate()([dec1, skip2])
    dec1 = tf.keras.layers.Conv2D(128, (3, 3), padding='same', activation='relu')(dec1)
    dec1 = tf.keras.layers.Conv2D(128, (3, 3), padding='same', activation='relu')(dec1)

    dec2 = tf.keras.layers.UpSampling2D((2, 2))(dec1)
    dec2 = tf.keras.layers.Concatenate()([dec2, skip1])
    dec2 = tf.keras.layers.Conv2D(64, (3, 3), padding='same', activation='relu')(dec2)
    dec2 = tf.keras.layers.Conv2D(64, (3, 3), padding='same', activation='relu')(dec2)

    # Final decoder layer with sigmoid activation for binary output
    dec3 = tf.keras.layers.Conv2D(1, (3, 3), padding='same', activation='sigmoid')(dec2)

    # Create and return the model
    model = tf.keras.Model(inputs=x, outputs=dec3)
    return model

model = create_unet_model()
loss = tf.keras.losses.BinaryCrossentropy()
model.compile(optimizer='adam', loss=loss, metrics=['accuracy'])
history = model.fit(X_train,y_train, batch_size=16, epochs=5,validation_data=(X_test, y_test))

figure, axes = plt.subplots(3,3, figsize=(20,20))

for i in range(0,3):
    rand_num = random.randint(0,5)
    original_img = X_test[rand_num]
    axes[i,0].imshow(original_img)
    axes[i,0].title.set_text('Original Image')
    
    original_mask = y_test[rand_num]
    axes[i,1].imshow(original_mask)
    axes[i,1].title.set_text('Original Mask')
    
    original_img = np.expand_dims(original_img, axis=0)
    predicted_mask = model.predict(original_img).reshape(512,512)
    axes[i,2].imshow(predicted_mask)
    axes[i,2].title.set_text('Predicted Mask')