/* UriumBodyParser.java */
/* Generated By:JavaCC: Do not edit this line. UriumBodyParser.java */
//------------------------------------------------------------------//
//                        COPYRIGHT NOTICE                          //
//------------------------------------------------------------------//
// Copyright (c) 2024, Francisco J. Moreno Velo                     //
//                                                                  //
// Permission is hereby granted, free of charge, to any person      //
// obtaining a copy of this software and associated documentation   //
// files (the "Software"), to deal in the Software without          //
// restriction, including without limitation the rights to use,     //
// copy, modify, merge, publish, distribute, sublicense, and/or     //
// sell copies of the Software, and to permit persons to whom the   //
// Software is furnished to do so, subject to the following         //
// conditions:                                                      //
//                                                                  //
// - The above copyright notice and this permission notice shall be //
//   included in all copies or substantial portions of the Software.//
//                                                                  //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  //
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES  //
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND         //
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT      //
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,     //
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING     //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR    //
// OTHER DEALINGS IN THE SOFTWARE.                                  //
//------------------------------------------------------------------//

//------------------------------------------------------------------//
//                      Universidad de Huelva                       //
//          Departamento de Tecnologías de la Información           //
//   Área de Ciencias de la Computación e Inteligencia Artificial   //
//------------------------------------------------------------------//
//                                                                  //
//                         Urium compiler                           //
//                                                                  //
//------------------------------------------------------------------//

package urium.parser;

import java.util.Vector;
import urium.ast.*;
import urium.ast.expression.*;
import urium.ast.statement.*;
import urium.ast.struct.*;

public class UriumBodyParser implements UriumBodyParserConstants {

        //----------------------------------------------------------------//
        //                         Private members                        //
        //----------------------------------------------------------------//

        /**
	 * Error count
	 */
        private int errorCount;

        /**
	 * Error message
	 */
        private String errorMsg;

        //----------------------------------------------------------------//
        //                           Public methods                       //
        //----------------------------------------------------------------//

        /**
	 * Method to parse an Urium file
	 */
        public void parse(String name, SymbolTable symtab)
        {
            this.errorCount = 0;
            this.errorMsg = "";
                try
                {
                        symtab.setActiveLibrary(name);
                        CompilationUnit(symtab);
                }
                catch(Exception e)
                {
                    catchError(e);
                }
        }

        /**
	 * Gets the number of errors in the analysis
	 */
        public int getErrorCount()
        {
                return this.errorCount;
        }

        /**
	 * Get the error message of the analysis
	 */
        public String getErrorMsg()
        {
                return this.errorMsg;
        }

        //----------------------------------------------------------------//
        //                 Private methods (semantic checks)              //
        //----------------------------------------------------------------//

        /**
	 * Stores a parse error
	 */
        private void catchError(Throwable ex)
        {
                this.errorCount++;
                this.errorMsg += ex.toString();
        }

        /**
	 * Checks that the statement to be added to a block is reachable
	 */
        private boolean verifyReachableCode(Statement stm, BlockStatement block)
        {
                if(stm != null && block.returns() )
                {
                        int errorcode = SemanticException.UNREACHABLE_CODE_EXCEPTION;
                        catchError(new SemanticException(errorcode,getToken(0)));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that a variable is not duplicated
	 */
        private boolean verifyNonDuplicatedVariable(Token tk, SymbolTable symtab)
        {
                if(symtab.getVariableInScope(tk.image)!=null)
                {
                        int errorcode = SemanticException.DUPLICATE_VARIABLE_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that a condition is of boolean type.
	 */
        private boolean verifyConditionType(Token tk, Expression expr)
        {
                if(!TypeSystem.isBoolean( expr.getType() ))
                {
                        int errorcode = SemanticException.INVALID_CONDITION_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks the existence of a variable in an assignment statement
	 */
        private boolean verifyKnownVariable(Token tk, SymbolTable symtab)
        {
                if(symtab.getVariable(tk.image) == null)
                {
                        int errorcode = SemanticException.UNKNOWN_VARIABLE_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /** 
	 * Checks that the data types in an assignment statement are correct
	 */
        private boolean verifyAssignTypes(Token tk, Variable var, Expression expr)
        {
                if(!TypeSystem.isAssignable(var.getType(),expr.getType()))
                {
                        int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks the existence of a library in the symbol table
	 */
        private boolean verifyKnownLibrary(Token tk, String name, SymbolTable symtab)
        {
            String libname = symtab.getActiveLibrary().getLibraryNameFromAlias(name);
                if(libname == null)
                {
                        int errorcode = SemanticException.UNKNOWN_LIBRARY_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                if(symtab.getLibrary(libname) == null)
                {
                        int errorcode = SemanticException.UNKNOWN_LIBRARY_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks the existence of a procedure in the active library
	 */
        private boolean verifyKnownProcedure(Token tk, CallParameters param, SymbolTable symtab)
        {
                if(symtab.getActiveLibrary().getAnyProcedure(tk.image,param.getTypes()) == null)
                {
                        int errorcode = SemanticException.UNKNOWN_PROCEDURE_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks the existence of a public procedure in a certain library
	 */
        private boolean verifyKnownProcedure(Token tk, String procname, CallParameters param, LibraryDeclaration library)
        {
                if(library.getPublicProcedure(procname,param.getTypes()) == null)
                {
                        int errorcode = SemanticException.UNKNOWN_PROCEDURE_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that both operands of a logical expression (AND, OR) are boolean
	 */
        private boolean verifyBooleanTypes(Token tk, Expression exp1, Expression exp2)
        {
                if(!TypeSystem.isBoolean(exp1.getType()) || !TypeSystem.isBoolean(exp2.getType()))
                {
                        int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that the data types of the two operands of a relation are correct
	 */
        private boolean verifyRelationTypes(Token tk, int relop, Expression exp1, Expression exp2)
        {
                switch(relop)
                {
                case BinaryExpression.EQ:
                case BinaryExpression.NEQ:
                        if(!TypeSystem.isComparable(exp1.getType(),exp2.getType()))
                        {
                                int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                                catchError(new SemanticException(errorcode,tk));
                                return false;
                        }
                        return true;
                case BinaryExpression.GT:
                case BinaryExpression.GE:
                case BinaryExpression.LT:
                case BinaryExpression.LE:
                        if(!TypeSystem.isOrderable(exp1.getType(),exp2.getType()))
                        {
                                int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                                catchError(new SemanticException(errorcode,tk));
                                return false;
                        }
                        return true;
                }
                return true;
        }

        /**
	 * Checks that an expression is of boolean type (to be able to apply NOT)
	 */
        private boolean verifyBooleanType(Token tk, Expression expr)
        {
                if(!TypeSystem.isBoolean( expr.getType() ))
                {
                        int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that an expression is of numeric type (so that '+' and '-' can be applied)
	 */
        private boolean verifyNumericType(Token tk, Expression exp)
        {
                if(!TypeSystem.isNumeric(exp.getType()))
                {
                        int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that two expressions are of numeric type (so that '+','-','*'and'/' can be applied)
	 */
        private boolean verifyNumericTypes(Token tk, Expression exp1, Expression exp2)
        {
                if(!TypeSystem.isNumeric( exp1.getType() ) || !TypeSystem.isNumeric( exp2.getType() ))
                {
                        int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that two expressions are of integer type (so that '%' can be applied).
	 */
        private boolean verifyIntegerTypes(Token tk, Expression exp1, Expression exp2)
        {
                if(!TypeSystem.isInteger( exp1.getType() ) || !TypeSystem.isInteger( exp2.getType() ))
                {
                        int errorcode = SemanticException.TYPE_MISMATCH_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
                return true;
        }

        /**
	 * Checks that the value of an integer literal is correct
	 */
        private boolean verifyIntegerValue(Token tk)
        {
                try
                {
                if(tk.image.startsWith("0x") || tk.image.startsWith("0X")) IntegerLiteralExpression.parseHexInt(tk.image.substring(2));
                else if(tk.image.startsWith("0b") || tk.image.startsWith("0B")) IntegerLiteralExpression.parseBinaryInt(tk.image.substring(2));
                else if(tk.image.startsWith("0")) Integer.parseInt(tk.image,8);
                else Integer.parseInt(tk.image);
                return true;
                }
                catch(Exception e)
                {
                        int errorcode = SemanticException.NUMBER_FORMAT_EXCEPTION;
                        catchError(new SemanticException(errorcode,tk));
                        return false;
                }
        }

        //----------------------------------------------------------------//
        //   Private methods (semantic actions for handling statements)   //
        //----------------------------------------------------------------//

        /**
     * Semantic action to add a statement to a block of statements.
     */
    private void actionAddStatement(BlockStatement block, Statement stm)
    {
        if(stm == null) return;
        if(!verifyReachableCode(stm,block)) return;
        block.addStatement(stm);
    }

    /**
     * Semantic action to assign the body of a procedure
     */
    private void actionSetProcedureBody(Token tk, BlockStatement block, SymbolTable symtab)
    {
        Procedure proc = symtab.getActiveProcedure();
        if(proc != null) proc.setBody(block);
    }

        /**
	 * Semantic action that adds the declaration of a variable
	 */
        private Variable actionAddDeclaration(SymbolTable symtab, DataType type,Token tid)
        {
                if(!verifyNonDuplicatedVariable(tid, symtab)) return null;
                Variable var = new Variable(type, tid.image);
                symtab.addLocalVariable(var);
                return var;
        }

        /**
	 * Semantic action that adds an assignment statement
	 */
        private void actionAddAssignement(BlockStatement block, Token tk, Variable var, Expression exp)
        {
                if(exp != null && var != null)
                {
                        if(!verifyAssignTypes(tk, var, exp)) return;
                        VariableExpression varexp = new VariableExpression(var);
                        AssignStatement stm = new AssignStatement(varexp,exp);
                        block.addStatement(stm);
                }
        }

        /**
	 * Semantic action that obtains the instruction associated with a variable
	 * declaration. If there are no initializations, it returns null. If there
	 * is only one initialization, it returns that assignment. If there is more
	 * than one (in a list of declarations), it returns the block of assignments.
	 */
        private Statement actionGetStatementFromBlock(BlockStatement block)
        {
                Statement[] list = block.getStatementList();
                if(list.length == 0) return null;
                if(list.length == 1) return list[0];
                return block;
        }

        /**
	 * Semantic action that creates an if statement
	 */
        private Statement actionIfStatement(Token tk, Expression cond, Statement thenStm, Statement elseStm)
        {
                if(!verifyConditionType(tk,cond)) return null;
                return new IfStatement(cond,thenStm,elseStm);
        }

    /**
     * Semantic action that creates a while statement
     */
        private Statement actionWhileStatement(Token tk, Expression cond, Statement body)
    {
                if(!verifyConditionType(tk,cond)) return null;
                return new WhileStatement(cond,body);
    }

    /**
     * Semantic action that creates an endp statement
     */
        private Statement actionEndpStatement(Token tk, SymbolTable symtab)
        {
                return new EndpStatement();
        }

        /**
	 * Semantic action that creates an assignment statement
	 */
        private Statement actionAssignStatement(Token tk, Expression exp, SymbolTable symtab)
        {
                if(!verifyKnownVariable(tk,symtab)) return null;
                Variable var = symtab.getVariable(tk.image);
                if(!verifyAssignTypes(tk,var,exp)) return null;
                VariableExpression varexp = new VariableExpression(var);
                return new AssignStatement(varexp,exp);
        }

        /**
	 * Semantic action that creates a call instruction to a procedure in the same library
	 */
        private Statement actionCallStatement(Token tk, CallParameters param, SymbolTable symtab)
        {
                if(!verifyKnownProcedure(tk,param,symtab)) return null;
                Procedure called = symtab.getActiveLibrary().getAnyProcedure(tk.image,param.getTypes());
                return new CallStatement(called,param,symtab.getActiveLibrary());
        }

        /**
	 * Semantic action that creates a call instruction to a procedure in n imported library
	 */
        private Statement actionCallStatement(Token tid, String name, CallParameters param, SymbolTable symtab)
        {
                int last = name.lastIndexOf('.');
                String aliasname = name.substring(0,last);
                String procname= name.substring(last+1);

                if(!verifyKnownLibrary(tid,aliasname,symtab)) return null;
                String libname = symtab.getActiveLibrary().getLibraryNameFromAlias(aliasname);
                LibraryDeclaration lib = symtab.getLibrary(libname);
                if(!verifyKnownProcedure(tid,procname,param,lib)) return null;
                Procedure called = lib.getPublicProcedure(procname,param.getTypes());
                return new CallStatement(called,param,lib);
        }

        //----------------------------------------------------------------//
        //   Private methods (semantic actions for handling expressions)  //
        //----------------------------------------------------------------//

        /**
	 * Semantic action that creates a binary expression that defines
	 * an OR between two expressions
	 */
        private Expression actionOrExpression(Token tk,Expression exp1, Expression exp2)
        {
                if(exp1 == null || exp2 == null) return new BooleanLiteralExpression(false);
                if(!verifyBooleanTypes(tk,exp1,exp2)) return new BooleanLiteralExpression(false);
                int op = BinaryExpression.OR;
                Expression exp = new BinaryExpression(op, exp1, exp2);
                return exp;
        }

        /**
	 * Semantic action that creates a binary expression that defines
	 * an AND between two expressions
	 */
        private Expression actionAndExpression(Token tk,Expression exp1, Expression exp2)
        {
                if(exp1 == null || exp2 == null) return new BooleanLiteralExpression(false);
                if(!verifyBooleanTypes(tk,exp1,exp2)) return new BooleanLiteralExpression(false);
                int op = BinaryExpression.AND;
                Expression exp = new BinaryExpression(op, exp1, exp2);
                return exp;
        }

        /**
	 * Semantic action that creates a binary expression that defines
	 * a relation between two expressions
	 */
        private Expression actionRelExpression(Token tk, int op, Expression exp1, Expression exp2)
        {
                if(exp1 == null || exp2 == null) return new BooleanLiteralExpression(false);
                if(!verifyRelationTypes(tk, op, exp1, exp2)) return new BooleanLiteralExpression(false);
                Expression exp = new BinaryExpression(op, exp1, exp2);
                return exp;
        }

        /**
	 * Semantic action that creates a unary expression on another expression.
	 */
        private Expression actionUnaryExpression(Token tk, int op, Expression exp)
        {
                switch(op)
                {
                        case UnaryExpression.NONE:
                                return exp;
                        case UnaryExpression.NOT:
                                if(!verifyBooleanType(tk,exp)) return new BooleanLiteralExpression(false);
                                return new UnaryExpression(op,exp);
                        case UnaryExpression.MINUS:
                                if(!verifyNumericType(tk,exp)) return new IntegerLiteralExpression(0);
                                return new UnaryExpression(op,exp);
                        case UnaryExpression.PLUS:
                                if(!verifyNumericType(tk,exp)) return new IntegerLiteralExpression(0);
                                return exp;
                }
                return exp;
        }

        /**
	 * Semantic action that creates a binary expression in the form of addition or subtraction
	 */
        private Expression actionSumExpression(Token tk,int op, Expression exp1, Expression exp2)
        {
                if(exp1 == null || exp2 == null) return new IntegerLiteralExpression(0);
                if(!verifyNumericTypes(tk,exp1,exp2)) return new IntegerLiteralExpression(0);
                Expression exp = new BinaryExpression(op, exp1, exp2);
                return exp;
        }

        /**
	 * Semantic action that creates a binary expression in the form of a product, division or remainder
	 */
        private Expression actionProdExpression(Token tk,int op, Expression exp1, Expression exp2)
        {
                if(exp1 == null || exp2 == null) return new IntegerLiteralExpression(0);
                if(op == BinaryExpression.MOD && !verifyIntegerTypes(tk,exp1,exp2)) return new IntegerLiteralExpression(0);
                if(op != BinaryExpression.MOD && !verifyNumericTypes(tk,exp1,exp2)) return new IntegerLiteralExpression(0);
                Expression exp = new BinaryExpression(op, exp1, exp2);
                return exp;
        }

        /**
	 * Semantic action that creates a literal of integer type
	 */
        private LiteralExpression actionIntegerLiteral(Token tk)
        {
                if(!verifyIntegerValue(tk)) return new IntegerLiteralExpression(0);
                return new IntegerLiteralExpression(tk.image);
        }

        /**
	 * Semantic action that creates a reference to a variable
	 */
        private Expression actionReferenceExpression(Token tid, SymbolTable symtab)
        {
                return actionVariableExpression(tid, symtab);
        }

        /**
	 * Semantic action that creates a reference to a variable
	 */
        private Expression actionVariableExpression(Token tid, SymbolTable symtab)
        {
                if(!verifyKnownVariable(tid,symtab)) return new IntegerLiteralExpression(0);
                Variable var = symtab.getVariable(tid.image);
                return new VariableExpression(var);
        }

        /**
	 * Semantic action that creates an output parameter
	 */
        private Expression actionOutParameter(Token tid, SymbolTable symtab)
        {
                if(!verifyKnownVariable(tid,symtab)) return new IntegerLiteralExpression(0);
                Variable var = symtab.getVariable(tid.image);
                return new OutVariableExpression(var);
        }

/**************************************************************/
/*         EL AN�LISIS DE LA CABECERA COMIENZA AQU�           */
/**************************************************************/

/**
 * Parses the full content of a source file
 *
 * CompilationUnit ::= (InportClause)* UriumDecl
 */
  final public void CompilationUnit(SymbolTable symtab) throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IMPORT:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      ImportClause();
    }
    UriumDecl(symtab);
}

/**
 * Parse an import clause
 *
 * ImportClause ::= <IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* (<AS> <IDENTIFIER>)? <SEMICOLON> 
 */
  final public void ImportClause() throws ParseException {
    jj_consume_token(IMPORT);
    jj_consume_token(IDENTIFIER);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      jj_consume_token(DOT);
      jj_consume_token(IDENTIFIER);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AS:{
      jj_consume_token(AS);
      jj_consume_token(IDENTIFIER);
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
}

/**
 * Parses the declaration of a library (ordinary or native)
 *
 * UriumDecl ::=  LibraryDecl |  NativeDecl 
 */
  final public void UriumDecl(SymbolTable symtab) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LIBRARY:{
      LibraryDecl(symtab);
      break;
      }
    case NATIVE:{
      NativeDecl(symtab);
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

/**
 * Parses the declaration of an ordinary library
 *
 * LibraryDecl ::=  <LIBRARY> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <LBRACE> ( ProcedureDecl )* <RBRACE> 
 */
  final public void LibraryDecl(SymbolTable symtab) throws ParseException {
    jj_consume_token(LIBRARY);
    jj_consume_token(IDENTIFIER);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      jj_consume_token(DOT);
      jj_consume_token(IDENTIFIER);
    }
    jj_consume_token(LBRACE);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PRIVATE:
      case PUBLIC:{
        ;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        break label_4;
      }
      ProcedureDecl(symtab);
    }
    jj_consume_token(RBRACE);
}

/**
 * Parses the declaration of a procedure
 *
 * ProcedureDecl ::= Access <PROC> <IDENTIFIER> ArgumentDecl ProcedureBody
 */
  final public void ProcedureDecl(SymbolTable symtab) throws ParseException {Token tid;
  DataType[] args;
    Access();
    jj_consume_token(PROC);
    tid = jj_consume_token(IDENTIFIER);
    args = ArgumentDecl();
symtab.setActiveProcedure(tid.image, args);
    ProcedureBody(symtab);
}

/**
 * Parses the declaration of a native library
 *
 * NativeDecl ::=  <NATIVE> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <LBRACE> ( NativeProcedure )* <RBRACE> 
 */
  final public void NativeDecl(SymbolTable symtab) throws ParseException {
    jj_consume_token(NATIVE);
    jj_consume_token(IDENTIFIER);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_5;
      }
      jj_consume_token(DOT);
      jj_consume_token(IDENTIFIER);
    }
    jj_consume_token(LBRACE);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PRIVATE:
      case PUBLIC:{
        ;
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        break label_6;
      }
      NativeProcedure(symtab);
    }
    jj_consume_token(RBRACE);
}

/**
 * Parses the declaration of a procedure of a native library
 *
 * NativeProcedure ::= Access <PROC> <IDENTIFIER> ArgumentDecl <SEMICOLON>
 */
  final public void NativeProcedure(SymbolTable symtab) throws ParseException {
    Access();
    jj_consume_token(PROC);
    jj_consume_token(IDENTIFIER);
    ArgumentDecl();
    jj_consume_token(SEMICOLON);
}

/**
 * Parses an access modifier
 *
 * Access ::= <PUBLIC> | <PRIVATE>
 */
  final public void Access() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PUBLIC:{
      jj_consume_token(PUBLIC);
      break;
      }
    case PRIVATE:{
      jj_consume_token(PRIVATE);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

/**
 * Parses the declaration of arguments of a procedure
 *
 * ArgumentDecl ::= <LPAREN> ( Argument ( <COMMA> Argument )* )? <RPAREN>
 */
  final public DataType[] ArgumentDecl() throws ParseException {Vector<DataType > args = new Vector<DataType>();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case CHAR:
    case INT:
    case OUT:{
      Argument(args);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        Argument(args);
      }
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
DataType[] type = new DataType[args.size()];
        args.copyInto(type);
        return type;
}

/**
 * Parses the declaration of an argument
 *
 * Argument ::= ArgumentType <IDENTIFIER>
 */
  final public void Argument(Vector<DataType> args) throws ParseException {DataType type;
    type = tryArgumentType();
    jj_consume_token(IDENTIFIER);
args.add(type);
}

/**
 * Parses the data type of an argument
 *
 * ArgumentType ::= ( <OUT> )? ( <INT> | <CHAR> | <BOOLEAN> )
 */
  final public DataType tryArgumentType() throws ParseException {int[] lsync = { };
  int[] rsync = { IDENTIFIER };
  DataType type = DataType.mismatch_type;
    try {
      type = parseArgumentType();
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return type;
}

/**
 * Parses the data type of an argument
 *
 * ArgumentType ::= ( <OUT> )? ( <INT> | <CHAR> | <BOOLEAN> )
 */
  final public DataType parseArgumentType() throws ParseException {DataType type;
  boolean out = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OUT:{
      jj_consume_token(OUT);
out = true;
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INT:{
      jj_consume_token(INT);
type = (out? DataType.int_ref_type: DataType.int_type);
      break;
      }
    case CHAR:{
      jj_consume_token(CHAR);
type = (out? DataType.char_ref_type: DataType.char_type);
      break;
      }
    case BOOLEAN:{
      jj_consume_token(BOOLEAN);
type = (out? DataType.boolean_ref_type: DataType.boolean_type);
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return type;
}

/**
 * Parses the body of a procedure
 *
 * ProcedureBody ::= <LBRACE> ( Statement )* <RBRACE>
 */
  final public void ProcedureBody(SymbolTable symtab) throws ParseException {BlockStatement block = new BlockStatement();
  Statement stm;
  Token tk;
    jj_consume_token(LBRACE);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case CHAR:
      case ENDP:
      case IF:
      case INT:
      case WHILE:
      case IDENTIFIER:
      case LBRACE:
      case SEMICOLON:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_8;
      }
      stm = tryStatement(symtab);
actionAddStatement(block,stm);
    }
    tk = jj_consume_token(RBRACE);
actionSetProcedureBody(tk, block, symtab);
}

/**************************************************************/
/*             STATEMENT DESCRIPTIONS STARTS HERE             */
/**************************************************************/

/**
 * Parses a language statement
 *
 * Statement ::= Decl | IdStm | IfStm | WhileStm | EndpStm | NoStm | BlockStm
 */
  final public Statement tryStatement(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseStatement(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses a language statement
 *
 * Statement ::= Decl | IdStm | IfStm | WhileStm | EndpStm | NoStm | BlockStm
 */
  final public Statement parseStatement(SymbolTable symtab) throws ParseException {Statement stm;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case CHAR:
    case INT:{
      stm = tryDecl(symtab);
      break;
      }
    case IDENTIFIER:{
      stm = tryIdStm(symtab);
      break;
      }
    case IF:{
      stm = tryIfStm(symtab);
      break;
      }
    case WHILE:{
      stm = tryWhileStm(symtab);
      break;
      }
    case ENDP:{
      stm = tryEndpStm(symtab);
      break;
      }
    case SEMICOLON:{
      stm = tryNoStm(symtab);
      break;
      }
    case LBRACE:{
      stm = tryBlockStm(symtab);
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return stm;
}

/**
 * Parses the declaration of a variable (or a list of variables)
 *
 * Decl ::= Type <IDENTIFIER> Assignement ( <COMMA> <IDENTIFIER> Assignement )* <SEMICOLON>
 */
  final public Statement tryDecl(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseDecl(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses the declaration of a variable (or a list of variables)
 *
 * Decl ::= Type <IDENTIFIER> Assignement ( <COMMA> <IDENTIFIER> Assignement )* <SEMICOLON>
 */
  final public Statement parseDecl(SymbolTable symtab) throws ParseException {DataType type;
  Token tid;
  Expression exp;
  BlockStatement block = new BlockStatement();
  Variable var;
    type = tryType();
    tid = jj_consume_token(IDENTIFIER);
    exp = tryAssignement(symtab);
var = actionAddDeclaration(symtab, type, tid);
    actionAddAssignement(block,tid,var,exp);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      tid = jj_consume_token(IDENTIFIER);
      exp = tryAssignement(symtab);
var = actionAddDeclaration(symtab, type, tid);
      actionAddAssignement(block,tid,var,exp);
    }
    jj_consume_token(SEMICOLON);
    return actionGetStatementFromBlock(block);
}

/**
 * Parses a basic data type
 *
 * Type ::= <INT> | <CHAR> | <BOOLEAN>
 */
  final public DataType tryType() throws ParseException {int[] lsync = { };
  int[] rsync = { IDENTIFIER };
  DataType type = DataType.mismatch_type;
    try {
      type = parseType();
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return type;
}

/**
 * Parses a basic data type
 *
 * Type ::= <INT> | <CHAR> | <BOOLEAN>
 */
  final public DataType parseType() throws ParseException {DataType type;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INT:{
      jj_consume_token(INT);
type = DataType.int_type;
      break;
      }
    case CHAR:{
      jj_consume_token(CHAR);
type = DataType.char_type;
      break;
      }
    case BOOLEAN:{
      jj_consume_token(BOOLEAN);
type = DataType.boolean_type;
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return type;
}

/**
 * Parses the initial assignment of a variable
 *
 * Assignement ::= ( <ASSIGN>  Expr )? 
 */
  final public Expression tryAssignement(SymbolTable symtab) throws ParseException {int[] lsync = { };
  int[] rsync = { COMMA, SEMICOLON };
  Expression exp = null;
    try {
      exp = parseAssignement(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return exp;
}

/**
 * Parses the initial assignment of a variable
 *
 * Assignement ::= ( <ASSIGN>  Expr )? 
 */
  final public Expression parseAssignement(SymbolTable symtab) throws ParseException {Expression exp = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      jj_consume_token(ASSIGN);
      exp = tryExpr(symtab);
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    return exp;
}

/**
 * Parses an if statement
 *
 * IfStm ::= <IF> <LPAREN> Expr <RPAREN> Stm  ( <ELSE> Stm )?
 */
  final public Statement tryIfStm(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseIfStm(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses an if statement
 *
 * IfStm ::= <IF> <LPAREN> Expr <RPAREN> Stm  ( <ELSE> Stm )?
 */
  final public Statement parseIfStm(SymbolTable symtab) throws ParseException {Token tk;
  Expression cond;
  Statement thenStm;
  Statement elseStm = null;
    jj_consume_token(IF);
    tk = jj_consume_token(LPAREN);
    cond = tryExpr(symtab);
    jj_consume_token(RPAREN);
    thenStm = tryStatement(symtab);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ELSE:{
      jj_consume_token(ELSE);
      elseStm = tryStatement(symtab);
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    return actionIfStatement(tk,cond,thenStm,elseStm);
}

/**
 * Parses a while statement
 *
 * WhileStm ::= <WHILE> <LPAREN> Expr <RPAREN> Stm
 */
  final public Statement tryWhileStm(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseWhileStm(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses a while statement
 *
 * WhileStm ::= <WHILE> <LPAREN> Expr <RPAREN> Stm
 */
  final public Statement parseWhileStm(SymbolTable symtab) throws ParseException {Token tk;
  Expression cond;
  Statement body;
    jj_consume_token(WHILE);
    tk = jj_consume_token(LPAREN);
    cond = tryExpr(symtab);
    jj_consume_token(RPAREN);
    body = tryStatement(symtab);
    return actionWhileStatement(tk,cond,body);
}

/**
 * Parses an endp statement
 *
 * EndpStm ::= <ENDP> <SEMICOLON>
 */
  final public Statement tryEndpStm(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseEndpStm(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses an endp statement
 *
 * EndpStm ::= <ENDP> <SEMICOLON>
 */
  final public Statement parseEndpStm(SymbolTable symtab) throws ParseException {Token tk;
    tk = jj_consume_token(ENDP);
    jj_consume_token(SEMICOLON);
    return actionEndpStatement(tk,symtab);
}

/**
 * Parses an empty statement
 *
 * NoStm ::= <SEMICOLON>
 */
  final public Statement tryNoStm(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseNoStm(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses an empty statement
 *
 * NoStm ::= <SEMICOLON>
 */
  final public Statement parseNoStm(SymbolTable symtab) throws ParseException {
    jj_consume_token(SEMICOLON);
    return null;
}

/**
 * Parses an assignment or a procedure call
 *
 * IdStm ::= <ID> ( Assignement | ProcedureCall | (<DOT>  <ID>)+  ProcedureCall )  <SEMICOLON>
 */
  final public Statement tryIdStm(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseIdStm(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses an assignment or a procedure call
 *
 * IdStm ::= <ID> ( Assignment | ProcedureCall | (<DOT>  <ID>)+  ProcedureCall )  <SEMICOLON>
 */
  final public Statement parseIdStm(SymbolTable symtab) throws ParseException {Token tid1, tid2;
  Expression exp;
  CallParameters param;
  Statement stm;
  String libname="";
    tid1 = jj_consume_token(IDENTIFIER);
libname = tid1.image;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      jj_consume_token(ASSIGN);
      exp = tryExpr(symtab);
stm = actionAssignStatement(tid1,exp,symtab);
      break;
      }
    case LPAREN:{
      param = ProcedureCall(symtab);
stm = actionCallStatement(tid1,param,symtab);
      break;
      }
    case DOT:{
      label_10:
      while (true) {
        jj_consume_token(DOT);
        tid2 = jj_consume_token(IDENTIFIER);
libname += "."+tid2.image;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DOT:{
          ;
          break;
          }
        default:
          jj_la1[19] = jj_gen;
          break label_10;
        }
      }
      param = ProcedureCall(symtab);
stm = actionCallStatement(tid1,libname,param,symtab);
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(SEMICOLON);
    return stm;
}

/**
 * Parses a block of statements
 *
 * BlockStm ::= <LBRACE> ( Stm )* <RBRACE>
 */
  final public Statement tryBlockStm(SymbolTable symtab) throws ParseException {int[] lsync = { SEMICOLON };
  int[] rsync = { INT, CHAR, BOOLEAN, IF, WHILE, ENDP, RBRACE};
  Statement stm = null;
    try {
      stm = parseBlockStm(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return stm;
}

/**
 * Parses a block of statements
 *
 * BlockStm ::= <LBRACE> ( Stm )* <RBRACE>
 */
  final public Statement parseBlockStm(SymbolTable symtab) throws ParseException {BlockStatement block = new BlockStatement();
  Statement stm;
    jj_consume_token(LBRACE);
symtab.createScope();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case CHAR:
      case ENDP:
      case IF:
      case INT:
      case WHILE:
      case IDENTIFIER:
      case LBRACE:
      case SEMICOLON:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_11;
      }
      stm = tryStatement(symtab);
      actionAddStatement(block,stm);
    }
    jj_consume_token(RBRACE);
    symtab.deleteScope();
    return block;
}

/**************************************************************/
/*             EXPRESSION DESCRIPTIONS STARTS HERE            */
/**************************************************************/

/**
 * Parses an expression (considering the OR operator as the lowest priority)
 *
 * Expr ::= AndExpr ( <OR> AndExpr )*
 */
  final public Expression tryExpr(SymbolTable symtab) throws ParseException {int[] lsync = { };
  int[] rsync = { SEMICOLON, COMMA, RPAREN };
  Expression exp = null;
    try {
      exp = parseExpr(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return exp;
}

/**
 * Parses an expression (considering the OR operator as the lowest priority)
 *
 * Expr ::= AndExpr ( <OR> AndExpr )*
 */
  final public Expression parseExpr(SymbolTable symtab) throws ParseException {Expression exp1, exp2;
  Token tk;
    exp1 = tryAndExpr(symtab);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OR:{
        ;
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        break label_12;
      }
      tk = jj_consume_token(OR);
      exp2 = tryAndExpr(symtab);
exp1 = actionOrExpression(tk, exp1,exp2);
    }
    return exp1;
}

/**
 * Parses an expression at the AND operator priority level
 *
 * AndExpr ::= RelExpr ( <AND> RelExpr )*
 */
  final public Expression tryAndExpr(SymbolTable symtab) throws ParseException {int[] lsync = { };
  int[] rsync = { SEMICOLON, COMMA, RPAREN, OR };
  Expression exp = null;
    try {
      exp = parseAndExpr(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return exp;
}

/**
 * Parses an expression at the AND operator priority level
 *
 * AndExpr ::= RelExpr ( <AND> RelExpr )*
 */
  final public Expression parseAndExpr(SymbolTable symtab) throws ParseException {Expression exp1, exp2;
  Token tk;
    exp1 = tryRelExpr(symtab);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        break label_13;
      }
      tk = jj_consume_token(AND);
      exp2 = tryRelExpr(symtab);
exp1 = actionAndExpression(tk, exp1,exp2);
    }
    return exp1;
}

/**
 * Parses an expression at the comparator priority level
 *
 * RelExpr ::= SumExpr ( RelOp SumExpr )?
 */
  final public Expression tryRelExpr(SymbolTable symtab) throws ParseException {int[] lsync = { };
  int[] rsync = { SEMICOLON, COMMA, RPAREN, OR, AND };
  Expression exp = null;
    try {
      exp = parseRelExpr(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return exp;
}

/**
 * Parses an expression at the comparator priority level
 *
 * RelExpr ::= SumExpr ( RelOp SumExpr )?
 */
  final public Expression parseRelExpr(SymbolTable symtab) throws ParseException {Expression exp1, exp2;
  int op;
  Token tk;
    exp1 = trySumExpr(symtab);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQ:
    case LE:
    case GT:
    case LT:
    case GE:
    case NE:{
tk = getToken(1);
      op = RelOp();
      exp2 = trySumExpr(symtab);
exp1 = actionRelExpression(tk, op, exp1,exp2);
      break;
      }
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    return exp1;
}

/**
 * Parses a comparison operator
 *
 * RelOp ::= <EQ> | <NE> | <GT> | <GE> | <LT> | <LE>
 */
  final public int RelOp() throws ParseException {int op;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQ:{
      jj_consume_token(EQ);
op = BinaryExpression.EQ;
      break;
      }
    case NE:{
      jj_consume_token(NE);
op = BinaryExpression.NEQ;
      break;
      }
    case GT:{
      jj_consume_token(GT);
op = BinaryExpression.GT;
      break;
      }
    case GE:{
      jj_consume_token(GE);
op = BinaryExpression.GE;
      break;
      }
    case LT:{
      jj_consume_token(LT);
op = BinaryExpression.LT;
      break;
      }
    case LE:{
      jj_consume_token(LE);
op = BinaryExpression.LE;
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return op;
}

/**
 * Parses an expression at the priority level of addition
 * (an arithmetic expression)
 *
 * SumExpr ::= UnOp ProdExpr ( SumOp ProdExpr )*
 */
  final public Expression trySumExpr(SymbolTable symtab) throws ParseException {int[] lsync = { };
  int[] rsync = { SEMICOLON, COMMA, RPAREN, OR, AND, EQ, NE, GT, GE, LT, LE };
  Expression exp = null;
    try {
      exp = parseSumExpr(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return exp;
}

/**
 * Parses an expression at the priority level of addition
 * (an arithmetic expression)
 *
 * SumExpr ::= UnOp ProdExpr ( SumOp ProdExpr )*
 */
  final public Expression parseSumExpr(SymbolTable symtab) throws ParseException {Expression exp1, exp2;
  int unop, op;
  Token tk;
tk = getToken(1);
    unop = UnOp();
    exp1 = tryProdExpr(symtab);
exp1 = actionUnaryExpression(tk, unop,exp1);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        break label_14;
      }
tk = getToken(1);
      op = SumOp();
      exp2 = tryProdExpr(symtab);
exp1 = actionSumExpression(tk, op, exp1,exp2);
    }
    return exp1;
}

/**
 * Parses a unary operator
 *
 * UnOp ::= ( <NOT> | <MINUS>  | <PLUS>  )?
 */
  final public int UnOp() throws ParseException {int op = UnaryExpression.NONE;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NOT:
    case PLUS:
    case MINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT:{
        jj_consume_token(NOT);
op = UnaryExpression.NOT;
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
op = UnaryExpression.MINUS;
        break;
        }
      case PLUS:{
        jj_consume_token(PLUS);
op = UnaryExpression.PLUS;
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    return op;
}

/**
 * Parses an addition operator
 *
 * SumOp ::= <MINUS> | <PLUS>
 */
  final public int SumOp() throws ParseException {int op;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MINUS:{
      jj_consume_token(MINUS);
op = BinaryExpression.MINUS;
      break;
      }
    case PLUS:{
      jj_consume_token(PLUS);
op = BinaryExpression.PLUS;
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return op;
}

/**
 * Parses an expression at the priority level of product
 * (an arithmetic term)
 *
 * ProdExpr ::= Factor ( MultOp Factor )*
 */
  final public Expression tryProdExpr(SymbolTable symtab) throws ParseException {int[] lsync = { };
  int[] rsync = { SEMICOLON, COMMA, RPAREN, OR, AND, EQ, NE, GT, GE, LT, LE, PLUS, MINUS };
  Expression exp = null;
    try {
      exp = parseProdExpr(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return exp;
}

/**
 * Parses an expression at the priority level of product
 * (an arithmetic term)
 *
 * ProdExpr ::= Factor ( MultOp Factor )*
 */
  final public Expression parseProdExpr(SymbolTable symtab) throws ParseException {Expression exp1, exp2;
  int op;
  Token tk;
    exp1 = tryFactor(symtab);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PROD:
      case DIV:
      case MOD:{
        ;
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        break label_15;
      }
tk = getToken(1);
      op = MultOp();
      exp2 = tryFactor(symtab);
exp1 = actionProdExpression(tk, op, exp1,exp2);
    }
    return exp1;
}

/**
 * Parses a product operator
 *
 * MultOp ::= <PROD> | <DIV> | <MOD>
 */
  final public int MultOp() throws ParseException {int op;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PROD:{
      jj_consume_token(PROD);
op = BinaryExpression.PROD;
      break;
      }
    case DIV:{
      jj_consume_token(DIV);
op = BinaryExpression.DIV;
      break;
      }
    case MOD:{
      jj_consume_token(MOD);
op = BinaryExpression.MOD;
      break;
      }
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return op;
}

/**
 * Parses a factor
 *
 * Factor ::= Literal | Reference | <LPAREN> Expr <RPAREN>
 */
  final public Expression tryFactor(SymbolTable symtab) throws ParseException {int[] lsync = { };
  int[] rsync = { SEMICOLON, COMMA, RPAREN, OR, AND, EQ, NE, GT, GE, LT, LE, PLUS, MINUS, PROD, DIV, MOD };
  Expression exp = null;
    try {
      exp = parseFactor(symtab);
    } catch (Exception ex) {
catchError(ex);
    skipTo(lsync,rsync);
    }
    return exp;
}

/**
 * Parses a factor
 *
 * Factor ::= Literal | Reference | <LPAREN> Expr <RPAREN>
 */
  final public Expression parseFactor(SymbolTable symtab) throws ParseException {Expression exp;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case TRUE:
    case INTEGER_LITERAL:
    case CHAR_LITERAL:{
      exp = Literal();
      break;
      }
    case IDENTIFIER:{
      exp = Reference(symtab);
      break;
      }
    case LPAREN:{
      jj_consume_token(LPAREN);
      exp = tryExpr(symtab);
      jj_consume_token(RPAREN);
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return exp;
}

/**
 * Parses a literal
 *
 * Literal ::= <INTEGER_LITERAL> | <CHAR_LITERAL>  | <TRUE>  | <FALSE>
 */
  final public Expression Literal() throws ParseException {Expression exp;
  Token tk;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:{
      tk = jj_consume_token(INTEGER_LITERAL);
exp = actionIntegerLiteral(tk);
      break;
      }
    case CHAR_LITERAL:{
      tk = jj_consume_token(CHAR_LITERAL);
exp = new CharLiteralExpression(tk.image);
      break;
      }
    case TRUE:{
      jj_consume_token(TRUE);
exp = new BooleanLiteralExpression(true);
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
exp = new BooleanLiteralExpression(false);
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return exp;
}

/**
 * Parses a reference to a variable
 *
 * Reference ::= <IDENTIFIER>
 */
  final public Expression Reference(SymbolTable symtab) throws ParseException {Token tid;
    tid = jj_consume_token(IDENTIFIER);
    return actionReferenceExpression(tid,symtab);
}

/**
 * Parses the parameters of a procedure call
 *
 * ProcedureCall ::= <LPAREN> ( Parameter ( <COMMA> Parameter )* )? <RPAREN>
 */
  final public CallParameters ProcedureCall(SymbolTable symtab) throws ParseException {CallParameters param = new CallParameters();
  Expression exp;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FALSE:
    case OUT:
    case TRUE:
    case INTEGER_LITERAL:
    case CHAR_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case NOT:
    case PLUS:
    case MINUS:{
      exp = parseParameter(symtab);
param.addParameter(exp);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          break label_16;
        }
        jj_consume_token(COMMA);
        exp = parseParameter(symtab);
param.addParameter(exp);
      }
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    return param;
}

/**
 * Parses a procedure call parameter
 *
 * Parameter ::= <LPAREN> ( Parameter ( <COMMA> Parameter )* )? <RPAREN>
 */
  final public Expression parseParameter(SymbolTable symtab) throws ParseException {Token tid;
  Expression exp;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OUT:{
      jj_consume_token(OUT);
      tid = jj_consume_token(IDENTIFIER);
exp = actionOutParameter(tid, symtab);
      break;
      }
    case FALSE:
    case TRUE:
    case INTEGER_LITERAL:
    case CHAR_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case NOT:
    case PLUS:
    case MINUS:{
      exp = tryExpr(symtab);
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    return exp;
}

  void skipTo(int[] left, int[] right) throws ParseException {Token prev = getToken(0);
  Token next = getToken(1);
  boolean flag = false;
  if(prev.kind == EOF || next.kind == EOF) flag = true;
  for(int i=0; i<left.length; i++) if(prev.kind == left[i]) flag = true;
  for(int i=0; i<right.length; i++) if(next.kind == right[i]) flag = true;

  while(!flag)
  {
    getNextToken();
    prev = getToken(0);
    next = getToken(1);
    if(prev.kind == EOF || next.kind == EOF) flag = true;
    for(int i=0; i<left.length; i++) if(prev.kind == left[i]) flag = true;
    for(int i=0; i<right.length; i++) if(next.kind == right[i]) flag = true;
  }
  }

  /** Generated Token Manager. */
  public UriumBodyParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[37];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x8000,0x0,0x100,0x60000,0x0,0x500000,0x0,0x500000,0x500000,0x0,0x90600,0x80000,0x10600,0x81015600,0x81015600,0x0,0x10600,0x0,0x800,0x0,0x0,0x81015600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc2802000,0x42802000,0x0,0xc2882000,0xc2882000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x0,0x40,0x0,0x0,0x40,0x0,0x40,0x0,0x0,0x20,0x0,0x0,0x0,0x14,0x14,0x20,0x0,0x80,0x0,0x40,0xc1,0x14,0x4000,0x8000,0x3f00,0x3f00,0x60000,0x70000,0x70000,0x60000,0x380000,0x380000,0x1,0x0,0x20,0x70001,0x70001,};
	}

  /** Constructor with InputStream. */
  public UriumBodyParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public UriumBodyParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new UriumBodyParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 37; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 37; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public UriumBodyParser(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new UriumBodyParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 37; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new UriumBodyParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 37; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public UriumBodyParser(UriumBodyParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 37; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(UriumBodyParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 37; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[54];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 37; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 54; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
